
#ifndef LANGEN_CS_HPP
#define LANGEN_CS_HPP

#include "core/core/string.hpp"

// not for generator

core::String cs_syntax_error = cs("$1:$2 syntax error");
core::String cs_while_unhexing = cs("$1:$2 while unhexing $3");
core::String cs_verbose_switch = cs("-v");
core::String cs_no_machine_switch = cs("-n");
core::String cs_input_switch = cs("-i");
core::String cs_output_switch = cs("-o");
core::String cs_usage = cs("usage: langen [-v] -i file.pro -o file.hpp");
core::String cs_unknown_exception = cs("unknown exception");
core::String cs_byte_expected = cs("$1:$2 byte expected: $3.$4");
core::String cs_only_bytes_expected = cs("$1:$2 only bytes expected in: $3");
core::String cs_log_conflict = cs("conflict: node: $1 followed by: $2 reduction: $3-$4");
core::String cs_shift_reduce = cs("shift-reduce node: $1");
core::String cs_fake_product = cs("fake product: $1 not allowed in machine code generation");
core::String cs_star = cs("Star");
core::String cs_plus = cs("Plus");
core::String cs_ques = cs("Ques");
core::String cs_ps = cs("+");
core::String cs_string = cs("core::String");
core::String cs_byte = cs("Byte");
core::String cs_model = cs("Model");

// shorts

core::String cs_tabs = cs("\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t");
core::String cs_line = cs("\n");
core::String cs_line_zero = cs("\n\0");
core::String cs_zero = cs("0");
core::String cs_comma_zero = cs(", 0");
core::String cs_comma = cs(",");
core::String cs_comma_space = cs(", ");
core::String cs_space = cs(" ");
core::String cs_space_arg1 = cs(" $1");
core::String cs_comma_space_arg1 = cs(", $1");

// clazzes

core::String cs_file_begin =
	cs("// Generated by langen"
		"\n"
		"\n#ifndef Model_$1_HPP"
		"\n#define Model_$1_HPP"
		"\n"
		"\nNAMESPACE_BEGIN($1);"
		"\n");
core::String cs_clazz_merge =
	cs("\n"
		"\nclass Merge : public core::MutableString"
		"\n{"
		"\npublic:");
core::String cs_clazz_encode =
	cs("\n\tMerge& append(core::String& arg)"
		"\n\t{"
		"\n\t\tcore::String::append(arg);"
		"\n\t\treturn *this;"
		"\n\t}"
		"\n\tMerge& append(String arg)"
		"\n\t{"
		"\n\t\tif(arg)"
		"\n\t\t\tcore::String::append(*arg);"
		"\n\t\treturn *this;"
		"\n\t}"
		"\n\tMerge& append(Byte arg)"
		"\n\t{"
		"\n\t\tif(arg)"
		"\n\t\t\tcore::String::attach(arg);"
		"\n\t\treturn *this;"
		"\n\t}"
		"\n\tMerge()"
		"\n\t{"
		"\n"
		"\n\t}"
		"\n\tMerge(core::String& arg)"
		"\n\t{"
		"\n\t\tappend(arg);"
		"\n\t}"
		"\n\tMerge(String arg)"
		"\n\t{"
		"\n\t\tappend(arg);"
		"\n\t}"
		"\n\tMerge(Byte arg)"
		"\n\t{"
		"\n\t\tappend(arg);"
		"\n\t}"
		"\n};"
		"\n"
		"\ntemplate<typename Type>"
		"\ncore::String cast(Type& type)"
		"\n{"
		"\n\treturn Merge().append(type);"
		"\n};"
		"\n"
		"\nclass Encode : io::Encode"
		"\n{"
		"\npublic:"
		"\n\tEncode(io::Output& output) : io::Encode(output)"
		"\n\t{"
		"\n"
		"\n\t}");
core::String cs_clazz_build_begin =
	cs("\n\tEncode& write(core::String& arg)"
		"\n\t{"
		"\n\t\tio::Encode::write(arg);"
		"\n\t\treturn *this;"
		"\n\t}"
		"\n\tEncode& write(String arg)"
		"\n\t{"
		"\n\t\tif(arg)"
		"\n\t\t\tio::Encode::write(*arg);"
		"\n\t\treturn *this;"
		"\n\t}"
		"\n\tEncode& write(Byte arg)"
		"\n\t{"
		"\n\t\tif(arg)"
		"\n\t\t\tio::Encode::write(arg);"
		"\n\t\treturn *this;"
		"\n\t}"
		"\n};"
		"\n"
		"\nclass Build"
		"\n{"
		"\npublic:"
		"\n\tBuild() : the_line_cnt(1), the_string_list(0x4F)"
		"\n\t{"
		"\n"
		"\n\t}"
		"\n\tvoid release()"
		"\n\t{"
		"\n\t\tthe_string_list.erase_all();"
		"\n\t\tthe_pager.release();"
		"\n\t}");
core::String cs_clazz_build_end =
	cs("\n\tString acquire_String()"
		"\n\t{"
		"\n\t\treturn &the_string_list.append();"
		"\n\t}"
		"\n\ttemplate<typename Type>"
		"\n\tString acquire_String(Type type)"
		"\n\t{"
		"\n\t\tString st = &the_string_list.append();"
		"\n\t\tst->append(type);"
		"\n\t\treturn st;"
		"\n\t}"
		"\n\tString type_to_var(String arg)"
		"\n\t{"
		"\n\t\tcore::uint8 upper = 0;"
		"\n\t\tcore::uint32 pos = 0;"
		"\n\t\tcore::uint32 last = 0;"
		"\n\t\tString result = the_pager.create<core::String>();"
		"\n\t\tcore::String::Iterator it = arg->head();"
		"\n\t\tif(it.next())"
		"\n\t\t{"
		"\n\t\t\tcore::uint8 byte = it.value();"
		"\n\t\t\tif(::isupper(byte))"
		"\n\t\t\t{"
		"\n\t\t\t\tcore::uint8 lower = ::tolower(byte);"
		"\n\t\t\t\tresult->copy_in(pos, &lower, sizeof(lower));"
		"\n\t\t\t\tlast = 1;"
		"\n\t\t\t}"
		"\n\t\t}"
		"\n\t\twhile(it.next())"
		"\n\t\t{"
		"\n\t\t\tcore::uint8 byte = it.value();"
		"\n\t\t\tif(::isupper(byte))"
		"\n\t\t\t\tupper = byte;"
		"\n\t\t\telse if(::islower(byte) && upper)"
		"\n\t\t\t{"
		"\n\t\t\t\tresult->copy_in(pos, arg->data() + last, it.position() - last - 1);"
		"\n\t\t\t\tlast = it.position();"
		"\n\t\t\t\tcore::uint8 lower[] = { '_', ::tolower(upper) };"
		"\n\t\t\t\tresult->copy_in(pos, lower, sizeof(lower));"
		"\n\t\t\t\tupper = 0;"
		"\n\t\t\t}"
		"\n\t\t}"
		"\n\t\tif(pos)"
		"\n\t\t{"
		"\n\t\t\tcore::assert(last <= arg->size());"
		"\n\t\t\tresult->copy_in(pos, arg->data() + last, arg->size() - last);"
		"\n\t\t\tresult->size(pos);"
		"\n\t\t\treturn result;"
		"\n\t\t}"
		"\n\t\treturn arg;"
		"\n\t}"
		"\n\tString var_to_type(String arg)"
		"\n\t{"
		"\n\t\tbool underscore = false;"
		"\n\t\tcore::uint32 pos = 0;"
		"\n\t\tcore::uint32 last = 0;"
		"\n\t\tString result = the_pager.create<core::String>();"
		"\n\t\tcore::String::Iterator it = arg->head();"
		"\n\t\tif(it.next())"
		"\n\t\t{"
		"\n\t\t\tcore::uint8 byte = it.value();"
		"\n\t\t\tif(::islower(byte))"
		"\n\t\t\t{"
		"\n\t\t\t\tcore::uint8 upper = ::toupper(byte);"
		"\n\t\t\t\tresult->copy_in(pos, &upper, sizeof(upper));"
		"\n\t\t\t\tlast = 1;"
		"\n\t\t\t}"
		"\n\t\t}"
		"\n\t\twhile(it.next())"
		"\n\t\t{"
		"\n\t\t\tcore::uint8 byte = it.value();"
		"\n\t\t\tif('_' == byte)"
		"\n\t\t\t\tunderscore = true;"
		"\n\t\t\telse if(::islower(byte) && underscore)"
		"\n\t\t\t{"
		"\n\t\t\t\tresult->copy_in(pos, arg->data() + last, it.position() - last - 1);"
		"\n\t\t\t\tlast = it.position() + 1;"
		"\n\t\t\t\tcore::uint8 upper = ::toupper(byte);"
		"\n\t\t\t\tresult->copy_in(pos, &upper, sizeof(upper));"
		"\n\t\t\t\tunderscore = false;"
		"\n\t\t\t}"
		"\n\t\t}"
		"\n\t\tif(pos)"
		"\n\t\t{"
		"\n\t\t\tcore::assert(last <= arg->size());"
		"\n\t\t\tresult->copy_in(pos, arg->data() + last, arg->size() - last);"
		"\n\t\t\tresult->size(pos);"
		"\n\t\t\treturn result;"
		"\n\t\t}"
		"\n\t\treturn arg;"
		"\n\t}"
		"\n\tcore::uint16 line_cnt()"
		"\n\t{"
		"\n\t\treturn the_line_cnt;"
		"\n\t}"
		"\nprotected:"
		"\n\tcore::uint16 the_line_cnt;"
		"\nprivate:"
		"\n\tcore::List<core::String> the_string_list;"
		"\n\tcore::Pager the_pager;"
		"\n};");
core::String cs_clazz_decode_begin =
	cs("\n"
		"\nclass Decode : public Build"
		"\n{"
		"\npublic:"
		"\n\tDecode()"
		"\n\t{"
		"\n\t\trelease();"
		"\n\t}"
		"\n\tvoid release()"
		"\n\t{"
		"\n\t\tBuild::release();"
		"\n\t\tthe_heap = the_queue - 1;"
		"\n\t\tthe_code = the_code_$1d;"
		"\n\t\tthe_model = 0;"
		"\n\t}");
core::String cs_clazz_decode_end =
	cs("\n\tHeap the_queue[core::uint8_max];"
		"\n\tHeap* the_heap;"
		"\n\tcore::uint32 the_code;"
		"\n\tModel the_model;"
		"\n};");
core::String cs_file_end =
	cs("\n"
		"\nNAMESPACE_END($1);"
		"\n"
		"\n#endif // Model_$1_HPP"
		"\n");

// machine comments

core::String cs_machine_comment_begin = cs("\n/*\n * ");
core::String cs_machine_comment_line = cs("\n *");
core::String cs_machine_comment_line_indent = cs("\n *$1");
core::String cs_machine_comment_conflict = cs("!");
core::String cs_machine_comment_merge = cs("|");
core::String cs_machine_comment_shift = cs(">");
core::String cs_machine_comment_reduce = cs("<");
core::String cs_machine_comment_end = cs("\n */");

// machine

core::String cs_machine_1d_begin =
	cs("\nconst core::uint32 the_checkset_width = $1;"
		"\nconst core::uint32 the_checkset_mask = $2;"
		"\nconst core::uint32 the_code_1d = $3;"
		"\nconst core::uint32 the_state_machine_1d[] = {");
core::String cs_machine_1d_end = cs(" };");
core::String cs_machine_2d_begin =
	cs("\n"
		"\nconst core::uint32 the_code_2d = 0;"
		"\nconst core::uint32 the_state_machine_2d[][$1] = {");
core::String cs_machine_2d_end = cs("\n};");
core::String cs_machine_2d_state_begin = cs("\n\t/*\t$1\t*/\t{ ");
core::String cs_machine_2d_comma_state_begin = cs(",\n\t/*\t$1\t*/\t{ ");
core::String cs_machine_2d_comma_cell = cs(", $1<<2|$2");
core::String cs_machine_2d_cell = cs("$1<<2|$2");
core::String cs_machine_2d_state_end = cs(" }");

// types

core::String cs_input_id_begin = cs("\n\nconst core::uint32 the_input_ids[core::uint8_max] = { ");
core::String cs_input_id_end = cs(" };\n");
core::String cs_basics =
	cs("\ntypedef core::String* String;"
		"\ntypedef core::uint8 Byte;"
		"\n");
core::String cs_decl_known_string = cs("\ncore::String $1 = cs(\"$2\"); //");
core::String cs_decl_known_byte = cs("\nconst Byte $1 = '$2'; // $3");
core::String cs_struct_forward = cs("\nstruct $1Struct;");
core::String cs_typedef_list = cs("\ntypedef $1Struct* $1; // $2");
core::String cs_typedef_complex = cs("\ntypedef $1Struct* $2; // $3");
core::String cs_typedef_string = cs("\ntypedef String $2; // $3");
core::String cs_typedef_byte = cs("\ntypedef Byte $2; // $3");
core::String cs_struct_list = cs("\n\nstruct $1Struct : core::List<$2>\n{\n\n};");
core::String cs_struct_begin = cs("\n\nstruct $1Struct\n{\n\tcore::uint16 line;");
core::String cs_struct_begin_reduction = cs("\n\nstruct $1Struct\n{\n\tcore::uint16 line;\n\tcore::uint16 reduction;");
core::String cs_struct_field = cs("\n\t$1 $2;");
core::String cs_struct_end = cs("\n};");

// append

core::String cs_decl_append_list =
	cs("\n\tMerge& append($1 $2)"
		"\n\t{"
		"\n\t\tif($2)"
		"\n\t\t{"
		"\n\t\t\tcore::List<$3>::Iterator it = $2->head();"
		"\n\t\t\twhile(it.next())"
		"\n\t\t\t{"
		"\n\t\t\t\t$3 $4 = it.value();"
		"\n\t\t\t\tappend($4);"
		"\n\t\t\t}"
		"\n\t\t}"
		"\n\t\treturn *this;"
		"\n\t}");
core::String cs_decl_append_abstract =
	cs("\n\tvirtual Merge& append($1 $2)"
		"\n\t{"
		"\n\t\treturn *this;"
		"\n\t}");
core::String cs_decl_append_begin =
	cs("\n\tMerge& append($1 $2)"
		"\n\t{"
		"\n\t\tif($2)"
		"\n\t\t{");
core::String cs_call_append_field = cs("\n\t\t\tappend($1->$2);");
core::String cs_call_append_static = cs("\n\t\t\tappend($1);");
core::String cs_decl_append_end = cs("\n\t\t}\n\t\treturn *this;\n\t}");
core::String cs_decl_append_begin_switch =
	cs("\n\tMerge& append($1 $2)"
		"\n\t{"
		"\n\t\tif($2)"
		"\n\t\t{"
		"\n\t\t\tswitch($2->reduction)"
		"\n\t\t\t{");
core::String cs_call_append_case_switch = cs("\n\t\t\tcase $1:");
core::String cs_call_append_field_switch = cs("\n\t\t\t\tappend($1->$2);");
core::String cs_call_append_static_switch = cs("\n\t\t\t\tappend($1);");
core::String cs_call_append_break_switch = cs("\n\t\t\t\tbreak;");
core::String cs_decl_append_end_switch =
	cs("\n\t\t\t}"
		"\n\t\t}"
		"\n\t\treturn *this;"
		"\n\t}");

// write

core::String cs_decl_write_list =
	cs("\n\tEncode& write($1 $2)"
		"\n\t{"
		"\n\t\tif($2)"
		"\n\t\t{"
		"\n\t\t\tcore::List<$3>::Iterator it = $2->head();"
		"\n\t\t\twhile(it.next())"
		"\n\t\t\t{"
		"\n\t\t\t\t$3 $4 = it.value();"
		"\n\t\t\t\twrite($4);"
		"\n\t\t\t}"
		"\n\t\t}"
		"\n\t\treturn *this;"
		"\n\t}");
core::String cs_decl_write_abstract =
	cs("\n\tvirtual Encode& write($1 $2)"
		"\n\t{"
		"\n\t\treturn *this;"
		"\n"
		"\n\t}");
core::String cs_decl_write_begin =
	cs("\n\tEncode& write($1 $2)"
		"\n\t{"
		"\n\t\tif($2)"
		"\n\t\t{");
core::String cs_call_write_field = cs("\n\t\t\twrite($1->$2);");
core::String cs_call_write_static = cs("\n\t\t\twrite($1);");
core::String cs_decl_write_end =
	cs("\n\t\t}"
		"\n\t\treturn *this;"
		"\n\t}");
core::String cs_decl_write_begin_switch =
	cs("\n\tEncode& write($1 $2)"
		"\n\t{"
		"\n\t\tif($2)"
		"\n\t\t{"
		"\n\t\t\tswitch($2->reduction)"
		"\n\t\t\t{");
core::String cs_call_write_case_switch = cs("\n\t\t\tcase $1:");
core::String cs_call_write_field_switch = cs("\n\t\t\t\twrite($1->$2);");
core::String cs_call_write_static_switch = cs("\n\t\t\t\twrite($1);");
core::String cs_call_write_break_switch = cs("\n\t\t\t\tbreak;");
core::String cs_decl_write_end_switch =
	cs("\n\t\t\t}"
		"\n\t\t}"
		"\n\t\treturn *this;"
		"\n\t}");

// acquire

core::String cs_decl_acquire = cs("\n\t$1 acquire_$1$2(");
core::String cs_decl_virtual_acquire = cs("\n\tvirtual $1 acquire_$1$2(");
core::String cs_decl_arg = cs("$1 $2");
core::String cs_decl_comma_arg = cs(", $1 $2");
core::String cs_acquire_list_arg0 =
	cs("\n\t$1 acquire_$1()"
		"\n\t{"
		"\n\t\t$1 var = the_pager.create<$1Struct>();"
		"\n\t\tvar->page_size(0x11);"
		"\n\t\treturn var;"
		"\n\t}");
core::String cs_acquire_list_arg2 =
	cs(")"
		"\n\t{"
		"\n\t\t$1 var = $2;"
		"\n\t\tvar->append($3);");
core::String cs_acquire_list_arg1 =
	cs(")"
		"\n\t{"
		"\n\t\t$1 var = the_pager.create<$1Struct>();"
		"\n\t\tvar->page_size(0x11);"
		"\n\t\tvar->append($3);");
core::String cs_acquire_complex =
	cs(")"
		"\n\t{"
		"\n\t\t$1 var = the_pager.acquire_nil<$1Struct>();"
		"\n\t\tvar->line = the_line_cnt;");
core::String cs_acquire_complex_reduction =
	cs(")"
		"\n\t{"
		"\n\t\t$1 var = the_pager.acquire_nil<$1Struct>();"
		"\n\t\tvar->reduction = $2;"
		"\n\t\tvar->line = the_line_cnt;");
core::String cs_acquire_string =
	cs(")"
		"\n\t{"
		"\n\t\tMerge* var = (Merge*)&the_string_list.append();");
core::String cs_acquire_abstract =
	cs(")"
		"\n\t{"
		"\n\t\t$1 var = 0;");
core::String cs_assign = cs("\n\t\tvar->$1 = $1;");
core::String cs_append = cs("\n\t\tvar->append($1);");
core::String cs_return_var = cs("\n\t\treturn var;\n\t}");

// put

core::String cs_put_begin =
	cs("\n\tbool put(core::uint8 byte)"
		"\n\t{"
		"\n\t\tif('\\n' == byte)"
		"\n\t\t\tthe_line_cnt++;"
		"\n\t\tcore::uint32 input_id = the_input_ids[byte];"
		"\n\t\tif(!input_id)"
		"\n\t\t\treturn false;"
		"\n\t\tbool shifted = false;"
		"\n\t\twhile(!shifted)"
		"\n\t\t{"
		"\n\t\t\tcore::uint32 state = the_code >> 2; // get rid of flags"
		"\n\t\t\tthe_code = $1"
		"\n\t\t\tif(the_code & 1) // shift"
		"\n\t\t\t{"
		"\n\t\t\t\tthe_heap++;"
		"\n\t\t\t\tthe_heap->state = state;"
		"\n\t\t\t\tthe_heap->byte = (Byte)byte;"
		"\n\t\t\t\tshifted = true;"
		"\n\t\t\t}"
		"\n\t\t\twhile(the_code & 2) // reduce"
		"\n\t\t\t{"
		"\n\t\t\t\tswitch(the_code >> 2) // get rid of flags"
		"\n\t\t\t\t{");
core::String cs_input_machine_1d =
	cs("the_state_machine_1d[state + input_id];"
		"\n\t\t\tif(!the_code || (the_code ^ state) & the_checkset_mask)"
		"\n\t\t\t\treturn false;"
		"\n\t\t\tthe_code >>= the_checkset_width;");
core::String cs_input_machine_2d =
	cs("the_state_machine_2d[state][input_id];"
		"\n\t\t\tif(!the_code)"
		"\n\t\t\t\treturn false;");
core::String cs_reduction_case = cs("\n\t\t\t\tcase reduction_$1$2:");
core::String cs_empty_reduction =
	cs("\n\t\t\t\t\tthe_heap++;"
		"\n\t\t\t\t\tthe_heap->state = state;"
		"\n\t\t\t\t\tthe_heap->$1 = 0;");
core::String cs_call_acquire_begin = cs("\n\t\t\t\t\tthe_heap->$1 = acquire_$2$3(");
core::String cs_call_acquire_increase_begin =
	cs("\n\t\t\t\t\tthe_heap++;"
		"\n\t\t\t\t\tthe_heap->state = state;"
		"\n\t\t\t\t\tthe_heap->$1 = acquire_$2$3(");
core::String cs_call_acquire_decrease_begin =
	cs("\n\t\t\t\t\tthe_heap -= $4;"
		"\n\t\t\t\t\tthe_heap->$1 = acquire_$2$3(");
core::String cs_cast_heap_direct = cs("the_heap->$1");
core::String cs_cast_heap = cs("(the_heap+$1)->$2");
core::String cs_call_acquire_end = cs(");");
core::String cs_state_machine_1d =
	cs("\n\t\t\t\t\tthe_code = the_state_machine_1d[the_heap->state + product_$1];"
		"\n\t\t\t\t\tbreak;");
core::String cs_state_machine_2d =
	cs("\n\t\t\t\t\tthe_code = the_state_machine_2d[the_heap->state][product_$1];"
		"\n\t\t\t\t\tbreak;");
core::String cs_check_machine_1d =
	cs("\n\t\t\t\t}"
		"\n\t\t\t\tif(!the_code || (the_code ^ the_heap->state) & the_checkset_mask)"
		"\n\t\t\t\t\treturn false;"
		"\n\t\t\t\tthe_code >>= the_checkset_width;");
core::String cs_end_machine_2d = cs("\n\t\t\t\t}");
core::String cs_put_return =
	cs("\n\t\t\t\t\tthe_model = the_heap->$1;"
		"\n\t\t\t\t\treturn false;");
core::String cs_put_end =
	cs("\n\t\t\t}"
		"\n\t\t}"
		"\n\t\treturn true;"
		"\n\t}"
		"\n\t$1 model()"
		"\n\t{"
		"\n\t\treturn the_model;"
		"\n\t}"
		"\nprivate:");

// enum product

core::String cs_enum_product_begin = cs("\n\tenum Product\n\t{");
core::String cs_enum_product_item = cs("\n\t\tproduct_$1 = $2");
core::String cs_enum_product_end = cs("\n\t};");

// enum reduction

core::String cs_enum_reduction_begin = cs("\n\tenum Reduction\n\t{");
core::String cs_enum_reduction_item = cs("\n\t\treduction_$1$2 = $2");
core::String cs_enum_reduction_end = cs("\n\t};");

// heap

core::String cs_struct_heap_begin =
	cs("\n\tstruct Heap"
		"\n\t{"
		"\n\t\tcore::uint32 state;"
		"\n\t\tunion"
		"\n\t\t{");
core::String cs_struct_heap_item = cs("\n\t\t\t$1 $2;");
core::String cs_struct_heap_end =
	cs("\n\t\t\tByte byte;"
		"\n\t\t};"
		"\n\t};");

#endif // LANGEN_CS_HPP
