// Generated by llvm2cpp - DO NOT MODIFY!

#include <llvm/Pass.h>
#include <llvm/ADT/SmallVector.h>
#include <llvm/IR/Verifier.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/CallingConv.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/GlobalVariable.h>
#include <llvm/IR/IRPrintingPasses.h>
#include <llvm/IR/InlineAsm.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/IR/Module.h>
#include <llvm/Support/FormattedStream.h>
#include <llvm/Support/MathExtras.h>
#include <algorithm>
using namespace llvm;

Module* makeLLVMModule();

int main(int argc, char**argv) {
	Module* Mod = makeLLVMModule();
	verifyModule(*Mod, &outs());
	outs() << "\nModule" << *Mod << "\n";
	return 0;
}


Module* makeLLVMModule() {
	// Module Construction
	Module* mod = new Module("test.cpp.ll", getGlobalContext());
	mod->setDataLayout("");
	mod->setTargetTriple("x86_64-pc-linux-gnu");

	// Type Definitions
	std::vector<Type*>FuncTy_0_args;
	FunctionType* FuncTy_0 = FunctionType::get(
	        /*Result=*/ IntegerType::get(mod->getContext(), 32),
	        /*Params=*/ FuncTy_0_args,
	        /*isVarArg=*/ false);

	PointerType* PointerTy_1 = PointerType::get(IntegerType::get(mod->getContext(), 32), 0);

	PointerType* PointerTy_2 = PointerType::get(Type::getFloatTy(mod->getContext()), 0);

	PointerType* PointerTy_3 = PointerType::get(Type::getDoubleTy(mod->getContext()), 0);


	// Function Declarations

	Function* func_main = mod->getFunction("main");
	if (!func_main) {
		func_main = Function::Create(
		        /*Type=*/ FuncTy_0,
		        /*Linkage=*/ GlobalValue::ExternalLinkage,
		        /*Name=*/ "main", mod);
		func_main->setCallingConv(CallingConv::C);
	}
	AttributeSet func_main_PAL;
	{
		SmallVector<AttributeSet, 4> Attrs;
		AttributeSet PAS;
		{
			AttrBuilder B;
			B.addAttribute(Attribute::NoUnwind);
			B.addAttribute(Attribute::UWTable);
			PAS = AttributeSet::get(mod->getContext(), ~0U, B);
		}

		Attrs.push_back(PAS);
		func_main_PAL = AttributeSet::get(mod->getContext(), Attrs);

	}
	func_main->setAttributes(func_main_PAL);

	// Global Variable Declarations


	// Constant Definitions
	ConstantInt* const_int32_4 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("1"), 10));
	ConstantInt* const_int32_5 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("0"), 10));
	ConstantInt* const_int32_6 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("11"), 10));
	ConstantInt* const_int32_7 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("3"), 10));
	ConstantInt* const_int32_8 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("4"), 10));
	ConstantFP* const_float_9 = ConstantFP::get(mod->getContext(), APFloat(1.200000e+00f));
	ConstantFP* const_double_10 = ConstantFP::get(mod->getContext(), APFloat(3.400000e+00));

	// Global Variable Definitions

	// Function Definitions

	// Function: main (func_main)
	{

		BasicBlock* label_11 = BasicBlock::Create(mod->getContext(), "",func_main,0);

		// Block  (label_11)
		AllocaInst* ptr_12 = new AllocaInst(IntegerType::get(mod->getContext(), 32), "", label_11);
		ptr_12->setAlignment(4);
		AllocaInst* ptr_i = new AllocaInst(IntegerType::get(mod->getContext(), 32), "i", label_11);
		ptr_i->setAlignment(4);
		AllocaInst* ptr_z = new AllocaInst(IntegerType::get(mod->getContext(), 32), "z", label_11);
		ptr_z->setAlignment(4);
		AllocaInst* ptr_f = new AllocaInst(Type::getFloatTy(mod->getContext()), "f", label_11);
		ptr_f->setAlignment(4);
		AllocaInst* ptr_d = new AllocaInst(Type::getDoubleTy(mod->getContext()), "d", label_11);
		ptr_d->setAlignment(8);
		StoreInst* void_13 = new StoreInst(const_int32_5, ptr_12, false, label_11);
		void_13->setAlignment(4);
		StoreInst* void_14 = new StoreInst(const_int32_6, ptr_i, false, label_11);
		void_14->setAlignment(4);
		LoadInst* int32_15 = new LoadInst(ptr_i, "", false, label_11);
		int32_15->setAlignment(4);
		BinaryOperator* int32_16 = BinaryOperator::Create(Instruction::Mul, int32_15, const_int32_7, "", label_11);
		BinaryOperator* int32_17 = BinaryOperator::Create(Instruction::Add, const_int32_8, int32_16, "", label_11);
		StoreInst* void_18 = new StoreInst(int32_17, ptr_z, false, label_11);
		void_18->setAlignment(4);
		StoreInst* void_19 = new StoreInst(const_float_9, ptr_f, false, label_11);
		void_19->setAlignment(4);
		StoreInst* void_20 = new StoreInst(const_double_10, ptr_d, false, label_11);
		void_20->setAlignment(8);
		LoadInst* int32_21 = new LoadInst(ptr_z, "", false, label_11);
		int32_21->setAlignment(4);
		CastInst* float_22 = new SIToFPInst(int32_21, Type::getFloatTy(mod->getContext()), "", label_11);
		LoadInst* float_23 = new LoadInst(ptr_f, "", false, label_11);
		float_23->setAlignment(4);
		BinaryOperator* float_24 = BinaryOperator::Create(Instruction::FAdd, float_22, float_23, "", label_11);
		CastInst* double_25 = new FPExtInst(float_24, Type::getDoubleTy(mod->getContext()), "", label_11);
		LoadInst* double_26 = new LoadInst(ptr_d, "", false, label_11);
		double_26->setAlignment(8);
		BinaryOperator* double_27 = BinaryOperator::Create(Instruction::FAdd, double_25, double_26, "", label_11);
		CastInst* int32_28 = new FPToSIInst(double_27, IntegerType::get(mod->getContext(), 32), "", label_11);
		ReturnInst::Create(mod->getContext(), int32_28, label_11);

	}

	return mod;
}
