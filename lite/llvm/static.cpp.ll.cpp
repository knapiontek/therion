// Generated by llvm2cpp - DO NOT MODIFY!

#include <llvm/Pass.h>
#include <llvm/ADT/SmallVector.h>
#include <llvm/Analysis/Verifier.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/CallingConv.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/GlobalVariable.h>
#include <llvm/IR/IRPrintingPasses.h>
#include <llvm/IR/InlineAsm.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/IR/Module.h>
#include <llvm/Support/FormattedStream.h>
#include <llvm/Support/MathExtras.h>
#include <algorithm>
using namespace llvm;

Module* makeLLVMModule();

int main(int argc, char**argv) {
	Module* Mod = makeLLVMModule();
	verifyModule(*Mod, PrintMessageAction);
	PassManager PM;
	PM.add(createPrintModulePass(&outs()));
	PM.run(*Mod);
	return 0;
}


Module* makeLLVMModule() {
	// Module Construction
	Module* mod = new Module("static.cpp.ll", getGlobalContext());
	mod->setDataLayout("");
	mod->setTargetTriple("x86_64-pc-linux-gnu");

	// Type Definitions
	std::vector<Type*>FuncTy_0_args;
	FunctionType* FuncTy_0 = FunctionType::get(
	        /*Result=*/ IntegerType::get(mod->getContext(), 32),
	        /*Params=*/ FuncTy_0_args,
	        /*isVarArg=*/ false);

	PointerType* PointerTy_1 = PointerType::get(IntegerType::get(mod->getContext(), 32), 0);

	StructType *StructTy_struct_TestStruct = mod->getTypeByName("struct.TestStruct");
	if (!StructTy_struct_TestStruct) {
		StructTy_struct_TestStruct = StructType::create(mod->getContext(), "struct.TestStruct");
	}
	std::vector<Type*>StructTy_struct_TestStruct_fields;
	StructTy_struct_TestStruct_fields.push_back(IntegerType::get(mod->getContext(), 32));
	if (StructTy_struct_TestStruct->isOpaque()) {
		StructTy_struct_TestStruct->setBody(StructTy_struct_TestStruct_fields, /*isPacked=*/ false);
	}

	PointerType* PointerTy_2 = PointerType::get(StructTy_struct_TestStruct, 0);


	// Function Declarations

	Function* func_main = mod->getFunction("main");
	if (!func_main) {
		func_main = Function::Create(
		        /*Type=*/ FuncTy_0,
		        /*Linkage=*/ GlobalValue::ExternalLinkage,
		        /*Name=*/ "main", mod);
		func_main->setCallingConv(CallingConv::C);
	}
	AttributeSet func_main_PAL;
	{
		SmallVector<AttributeSet, 4> Attrs;
		AttributeSet PAS;
		{
			AttrBuilder B;
			B.addAttribute(Attribute::NoUnwind);
			B.addAttribute(Attribute::UWTable);
			PAS = AttributeSet::get(mod->getContext(), ~0U, B);
		}

		Attrs.push_back(PAS);
		func_main_PAL = AttributeSet::get(mod->getContext(), Attrs);

	}
	func_main->setAttributes(func_main_PAL);

	// Global Variable Declarations


	// Constant Definitions
	ConstantInt* const_int32_3 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("1"), 10));
	ConstantInt* const_int32_4 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("0"), 10));
	ConstantInt* const_int32_5 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("999"), 10));

	// Global Variable Definitions

	// Function Definitions

	// Function: main (func_main)
	{

		BasicBlock* label_6 = BasicBlock::Create(mod->getContext(), "",func_main,0);

		// Block  (label_6)
		AllocaInst* ptr_7 = new AllocaInst(IntegerType::get(mod->getContext(), 32), "", label_6);
		ptr_7->setAlignment(4);
		AllocaInst* ptr_ts = new AllocaInst(StructTy_struct_TestStruct, "ts", label_6);
		ptr_ts->setAlignment(4);
		StoreInst* void_8 = new StoreInst(const_int32_4, ptr_7, false, label_6);
		void_8->setAlignment(4);
		GetElementPtrInst* ptr_9 = GetElementPtrInst::Create(StructTy_struct_TestStruct, ptr_ts, {
		                                                             const_int32_4,
		                                                             const_int32_4
								     }, "", label_6);
		StoreInst* void_10 = new StoreInst(const_int32_5, ptr_9, false, label_6);
		void_10->setAlignment(4);
		GetElementPtrInst* ptr_11 = GetElementPtrInst::Create(StructTy_struct_TestStruct, ptr_ts, {
		                                                              const_int32_4,
		                                                              const_int32_4
								      }, "", label_6);
		LoadInst* int32_12 = new LoadInst(ptr_11, "", false, label_6);
		int32_12->setAlignment(4);
		ReturnInst::Create(mod->getContext(), int32_12, label_6);

	}

	return mod;
}
