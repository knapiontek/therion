// Generated by llvm2cpp - DO NOT MODIFY!

#include <llvm/Pass.h>
#include <llvm/ADT/SmallVector.h>
#include <llvm/Analysis/Verifier.h>
#include <llvm/IR/BasicBlock.h>
#include <llvm/IR/CallingConv.h>
#include <llvm/IR/Constants.h>
#include <llvm/IR/DerivedTypes.h>
#include <llvm/IR/Function.h>
#include <llvm/IR/GlobalVariable.h>
#include <llvm/IR/IRPrintingPasses.h>
#include <llvm/IR/InlineAsm.h>
#include <llvm/IR/Instructions.h>
#include <llvm/IR/LLVMContext.h>
#include <llvm/IR/LegacyPassManager.h>
#include <llvm/IR/Module.h>
#include <llvm/Support/FormattedStream.h>
#include <llvm/Support/MathExtras.h>
#include <algorithm>
using namespace llvm;

Module* makeLLVMModule();

int main(int argc, char**argv) {
	Module* Mod = makeLLVMModule();
	verifyModule(*Mod, PrintMessageAction);
	PassManager PM;
	PM.add(createPrintModulePass(&outs()));
	PM.run(*Mod);
	return 0;
}

Module* makeLLVMModule() {

	// Module Construction
	Module* mod = new Module("malloc.ll", getGlobalContext());
	mod->setDataLayout("");
	mod->setTargetTriple("x86_64-pc-linux-gnu");

	// Type Definitions
	std::vector<Type*> funcMainTy_args;
	FunctionType* funcMainTy = FunctionType::get(
	        /*Result=*/ IntegerType::get(mod->getContext(), 32),
	        /*Params=*/ funcMainTy_args,
	        /*isVarArg=*/ false);

	StructType* testStructTy = mod->getTypeByName("struct.TestStruct");
	if (!testStructTy) {
		testStructTy = StructType::create(mod->getContext(), "struct.TestStruct");
	}
	std::vector<Type*> testStructTy_fields;
	testStructTy_fields.push_back(IntegerType::get(mod->getContext(), 32));
	testStructTy_fields.push_back(Type::getDoubleTy(mod->getContext()));
	if (testStructTy->isOpaque()) {
		testStructTy->setBody(testStructTy_fields, /*isPacked=*/ false);
	}

	PointerType* pTestStructTy = PointerType::get(testStructTy, 0);
	PointerType* ppTestStructTy = PointerType::get(pTestStructTy, 0);
	PointerType* pInt8Ty = PointerType::get(IntegerType::get(mod->getContext(), 8), 0);

	std::vector<Type*> funcMallocTy_args;
	funcMallocTy_args.push_back(IntegerType::get(mod->getContext(), 64));
	FunctionType* funcMallocTy = FunctionType::get(
	        /*Result=*/ pInt8Ty,
	        /*Params=*/ funcMallocTy_args,
	        /*isVarArg=*/ false);

	PointerType* pFuncMallocTy = PointerType::get(funcMallocTy, 0);
	PointerType* pDoubleTy = PointerType::get(Type::getDoubleTy(mod->getContext()), 0);

	// Function Declarations
	Function* func_main = mod->getFunction("main");
	if (!func_main) {
		func_main = Function::Create(
		        /*Type=*/ funcMainTy,
		        /*Linkage=*/ GlobalValue::ExternalLinkage,
		        /*Name=*/ "main", mod);
		func_main->setCallingConv(CallingConv::C);
	}
	Function* func_malloc = mod->getFunction("malloc");
	if (!func_malloc) {
		func_malloc = Function::Create(
		        /*Type=*/ funcMallocTy,
		        /*Linkage=*/ GlobalValue::ExternalLinkage,
		        /*Name=*/ "malloc", mod); // (external, no body)
		func_malloc->setCallingConv(CallingConv::C);
	}

	// Constant Definitions
	ConstantInt* const_int32_1 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("1"), 10));
	ConstantInt* const_int32_0 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("0"), 10));
	ConstantInt* const_int64_16 = ConstantInt::get(mod->getContext(), APInt(64, StringRef("16"), 10));
	ConstantFP* const_double_2_0 = ConstantFP::get(mod->getContext(), APFloat(2.000000e+00));

	// Function: main (func_main)
	{
		BasicBlock* bb_main = BasicBlock::Create(mod->getContext(), "", func_main, 0);

		// alloca int32, store 0 into it
		AllocaInst* allocaInt32 = new AllocaInst(IntegerType::get(mod->getContext(), 32), "", bb_main);
		allocaInt32->setAlignment(4);
		StoreInst* storeAllocaInt32 = new StoreInst(const_int32_0, allocaInt32, false, bb_main);
		storeAllocaInt32->setAlignment(4);

		// alloca TestStruct
		AllocaInst* allocaTestStruct = new AllocaInst(pTestStructTy, "ts", bb_main);
		allocaTestStruct->setAlignment(8);

		// call malloc
		CallInst* callMalloc = CallInst::Create(func_malloc, const_int64_16, "", bb_main);
		callMalloc->setCallingConv(CallingConv::C);
		callMalloc->setTailCall(false);

		// cast malloc-return to TestStruct, store it
		CastInst* bitcastMallocToTestStruct = new BitCastInst(callMalloc, pTestStructTy, "", bb_main);
		StoreInst* storePTestStruct = new StoreInst(bitcastMallocToTestStruct, allocaTestStruct, false, bb_main);
		storePTestStruct->setAlignment(8);
		
		// load TestStruct, store 0 in first field
		LoadInst* loadPTestStruct = new LoadInst(allocaTestStruct, "", false, bb_main);
		loadPTestStruct->setAlignment(8);
		GetElementPtrInst* gep_ts_0 = GetElementPtrInst::Create(testStructTy,
																loadPTestStruct,
																{ const_int32_0, const_int32_0 },
																"", bb_main);
		StoreInst* store_ts_0 = new StoreInst(const_int32_1, gep_ts_0, false, bb_main);
		store_ts_0->setAlignment(8);
		
		// load TestStruct, store 2.0 in second field
		LoadInst* loadPTestStruct_again = new LoadInst(allocaTestStruct, "", false, bb_main);
		loadPTestStruct_again->setAlignment(8);
		GetElementPtrInst* gep_ts_1 = GetElementPtrInst::Create(testStructTy,
																loadPTestStruct_again,
																{ const_int32_0, const_int32_1 },
																"", bb_main);
		StoreInst* store_ts_1 = new StoreInst(const_double_2_0, gep_ts_1, false, bb_main);
		store_ts_1->setAlignment(8);

		// load TestStruct pointer, cast it to int
		LoadInst* loadPTestStruct_again1 = new LoadInst(allocaTestStruct, "", false, bb_main);
		loadPTestStruct_again1->setAlignment(8);
		CastInst* pTestStructToInt64 = new PtrToIntInst(loadPTestStruct_again1, IntegerType::get(mod->getContext(), 64), "", bb_main);
		CastInst* truncInt64ToInt32 = new TruncInst(pTestStructToInt64, IntegerType::get(mod->getContext(), 32), "", bb_main);
		ReturnInst::Create(mod->getContext(), truncInt64ToInt32, bb_main);
	}

	return mod;
}