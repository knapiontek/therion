%token_prefix TOK_
%token_type { Ref<Token> }
%extra_argument { Tree& tree }
%syntax_error { (void)yymajor; (void)yyminor; tree.syntax_error(); }
%destructor input { (void)yypminor; }

input ::= var_map.

var_map ::= var_map var.
var_map ::= var.
var_map ::= LP RP.

%type var { Ref<Var> }
var(v) ::= ID(i) COLON exp(e). { v = tree.var(i, e); }

%type exp { Ref<Exp> }
exp ::= exp op LB exp RB. {}
exp ::= LB exp RB. {}
exp ::= exp op loc. {}
exp ::= exp op type. {}
exp ::= loc. {}
exp ::= type. {}

%type loc { Ref<Loc> }
loc ::= loc DOT ID LS exp RS.
loc ::= loc DOT ID.
loc ::= ID LS exp RS.
loc ::= ID.

%type type { Type }
type(t) ::= BOOL. { t = Type::BOOL; }
type(t) ::= INT8. { t = Type::INT8; }
type(t) ::= INT16. { t = Type::INT16; }
type(t) ::= INT32. { t = Type::INT32; }
type(t) ::= INT64. { t = Type::INT64; }
type(t) ::= FLOAT32. { t = Type::FLOAT32; }
type(t) ::= FLOAT64. { t = Type::FLOAT64; }
type(t) ::= FLOAT128. { t = Type::FLOAT128; }

%type op { Op }
op(o) ::= MUL. { o = Op::MUL; }
op(o) ::= DIV. { o = Op::DIV; }
op(o) ::= MOD. { o = Op::MOD; }
op(o) ::= ADD. { o = Op::ADD; }
op(o) ::= SUB. { o = Op::SUB; }
op(o) ::= SHL. { o = Op::SHL; }
op(o) ::= SHR. { o = Op::SHR; }
op(o) ::= EQ. { o = Op::EQ; }
op(o) ::= NE. { o = Op::NE; }
op(o) ::= LE. { o = Op::LE; }
op(o) ::= LT. { o = Op::LT; }
op(o) ::= GE. { o = Op::GE; }
op(o) ::= GT. { o = Op::GT; }
op(o) ::= AND. { o = Op::AND; }
op(o) ::= OR. { o = Op::OR; }
op(o) ::= XOR. { o = Op::XOR; }
op(o) ::= NOT. { o = Op::NOT; }
