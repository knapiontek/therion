
string: ''
string: u8[]
int: i32

# single line comment

"""
    multi-line comment
    : initialize
    << >> copy
    <+ +> append, prepend
    <- -> function
"""

person-seq <+ person
seq[name = nil] << nil
nil << seq[name = nil]

# keywords: this, that, in, out, if, for, repeat, until

var: {1: 0, 2: 1}
var <+ {1: 1} # copy only field '1'

address-town: {town: string}
address: address-town {street: string, house-no: int}
address-ref: address
my-address: address {town: 'my-town', street: 'my-street', house-no: 1}
your-address: address {'your-town', 'your-street', 2}
their-address: address
   town: 'their-town'
   street: 'their-street'
   house-no: 3

family:
    last-name: string
    first-name-seq: string[]
    address-seq: address[]

family-seq: family[]

family-seq <+ family
    'Smith'
    ['John', 'Mark', 'Teddy', 'Betty']
    [{street: 'Avenue'}, {street: 'Strand'}]

function: (x: 0, y: 0) -> x + y

item: {street: address.street, house-no: address.house-no, family.last-name}

find-by-name(street: address.street, name: string) ->
    family-seq[.last-name = 'Smith' & first-name-seq[name]]
            .address-seq[.street = in.street]
        -> item {street, house-no, ..last-name}

function(in: f64) -> (out: 2 * in)
    if(out = false)
        out << true
    else if(in > 0.0)
        return

    # group locals
    (a, b, c): (1, 2, 3)
    (a, b, c) << (1, 2, 3)
    log.debug(a)

    for(p: person-seq)
        if(p.name.start-with('K'))
            log.debug(p.name)
    repeat
        until(condition)

    until(out > 100)
        out << (2 + in)
        repeat

result: function(5)
function(6) -> result

shade:
    var: 0i32
    function(var: 1.0f32) -> {var: 1i64}
        var: 'local'
        log.debug('closure: %1, local: %2, arg: %3, result: %4', that.var, this.var, in.var, out.var)

shade-result: shade.function(2.0)

# reflection
shade[name.start-with('test') & class >= function.class]
    (f: field) -> log.debug('test: %1', f.name)

# lock-free event-driven programming
file.write('data', (rc: int) -> log.debug('return-code: %1', rc))
queue.post(sync: shade, data: 'data')

# posponed code generation, template
person:
    name: unicode
    match(iterable: iterable(person))
        for(it: iterable)
            if(that = it.value())
                return true
        return false

seq(element: any)
    find(e: element) -> iterable(element)
    at(i: int) -> element
    match(equal: (e: element) -> bool) -> iterable(e)

people: seq(person)
for(p: people.match('John' = e.name))
    log.debug('person: $1', p)

#
# indentation
#

person: {name: 'John',
         last-name: 'Smith',
         data-of-brith: date {1974, 1, 1}}

john: person {name: 'John',
              last-name: 'Smith',
              data-of-brith: date {1974, 1, 1}}

person(name: 'John',
       last-name: 'Smith',
       data-of-brith: date(1974, 1, 1))

john: person
john: person()
john: person {}

person:
    name: 'John'
    last-name: 'Smith'
    data-of-brith: date
        year: 1974
        month: 1
        day: 1

# operator
    1 < x <= 2
    x + y
    x, y, z

    (r1: any < r2: any <= r2: any) -> any
    (r1: any + r2: any) -> any
    (r1: any, r2: any, r3: any) -> any

    condition([1] = 'John') -> snap(limit-definition-list)

    condition: (value: bool) -> (lambda: (value: any) -> nil)
        if(value)
            lambda(value)
