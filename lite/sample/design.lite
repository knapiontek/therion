
unicode: ''
unicode: 0u8[]
int: 0i32

# single line comment

"""
    multi-line comment
    x: 5 define new final
    var x: 5 define new variable 
    << >> copy
    <+ +> append, prepend
    <- -> define function
    function arg call function
    function(args) call function
"""


person-seq <+ person
seq[name = 'John'] << nil
nil << seq[name = 'John']

# keywords: if, for, repeat, until

var: (1: 0, 2: 1)
var <+ (1: 1) # copy only field '1'

address-town: (town: unicode)
address: address-town (street: unicode, house-no: int)
address-ref: address
my-address: address (town: 'my-town', street: 'my-street', house-no: 1)
your-address: address ('your-town', 'your-street', 2)
their-address: address
   var town: var 'their-town'
   street: 'their-street'
   house-no: 3

family:
    var last-name: unicode
    first-name-seq: unicode[]
    address-seq: address[]

family-seq: family[]

family-seq <+ family
    'Smith'
    ['John', 'Mark', 'Teddy', 'Betty']
    [(street: 'Avenue'), (street: 'Strand')]

function: (x: 0, y: 0) -> x + y

item: (street: address.street, house-no: address.house-no, family-last-name: family.last-name)

find-by-name(street: address.street, name: unicode) -> (item-seq: item[])
    for f: family-seq[last-name = 'Smith' & first-name-seq[name]]
        for a: f.address-seq[street = street]
            item-seq <+ item (street, a.house-no, f.last-name)

# or simplify if fields are unique, dots for embedding using vars (not mandatory if ids are unique)
find-by-name(street: address.street, name: unicode) >>
    family-seq[last-name = 'Smith' & first-name-seq[.name]]
        | address-seq[street = .street]
            >> item (street, house-no, last-name)

function(in: f64) -> in
	result: (0.0: 1.0, 1.0: 2.0)[in]

	result: case(in)
		0.0: 1.0
		1.0: 2.0
	
	case:
		out = false: out << true
		i > 0.0: -> 1.0
		: -> 2.0

	case out = false: out << true
	case: -> 2.0

    # group locals
    a, b, c: 1, 2, 3
    a, b, c << 1, 2, 3
    log.debug(a, b, c)

    for p: person-seq
        case p.name.start-with('Kris') & maybe:
            log.debug(p.name)
    repeat:
        until condition

    until out > 100:
        out << (2 + in)
        repeat

result: function(5)
function(6) -> result

# optional fixed access: local ., 1-up .., 2-up ...
# otherwise search upward for a match
shade:
    var up: 0i32 # mutable
    function(var in: 1.0f32) -> (out: 1i64)
        local: 'local'
        log.debug('closure: %1, local: %2, arg: %3, result: %4' % (..up, .local, .in, .out))
        log.debug <<< "closure: {..up}, local: {.local}, arg: {.in}, result: {.out}"
        log.debug <<< "closure: {up}, local: {local}, arg: {in}, result: {out}"

shade-result: shade.function(2.0)

# reflection
shade[name.start-with('test') & class >= function.class]
    on-element: (f: field) -> log.debug('test: %1', f.name)
    on-element: log.debug('test: %1', f.name) # guess arg from original: on-element: (f: field) -> bool

# lock-free event-driven programming
file.write('data')
    on-complete: (rc: int, message: unicode) -> log.debug('return-code: %1, message: %2', rc, message)

queue.post(sync: shade, data: 'data')

# posponed code generation, template
person:
    name: unicode
    match(iterable: iterable(person)) -> bool
        for it: iterable
            if that = it
                -> true
        -> false

seq(element: any)
    find(e: element) -> element[]
    at(i: int) -> element
    match(equal: (e: element) -> bool) -> element[]

people: seq(person)
for p: people.match('John' = e.name)
    log.debug('person: %1' % p)

#
# indentation
#

person: (name: 'John',
         last-name: 'Smith',
         date-of-brith: date <+ (1974, 1, 1))

john: person + (name: 'John',
                last-name: 'Smith',
                date-of-brith: date <+ (1974, 1, 1))

person(name: 'John',
       last-name: 'Smith',
       date-of-brith: date(1974, 1, 1))

john: person
john: person()

person:
    var name:: 'John'  # mutable variable
    last-name := 'Smith'
    date-of-brith: date
        year: 1974
        month: 1
        day: 1

dob: person.date-of-brith | (2001, 1, 1)
dob1: person.date-of-brith | (2001, 1, 1)

# operator
    1 < x <= 2
    x + y
    x, y, z

    (r1: any < r2: any <= r2: any) -> any
    (r1: any + r2: any) -> any
    (r1: any, r2: any, r3: any) -> any

    condition([1] = 'John') -> snap(john)

    condition: (value: bool) -> (lambda: (value: any) -> nil)
        if value
            lambda(value)

# operator with lambda

seq(element: any):
    element-seq: element[]
    [condition(el: element) -> bool] -> (on-select: (el: element) -> el)
        result: el[]
        for el: element-seq
            if condition(el)
                result <+ on-select(el)

person: (name: unicode, last-name: unicode)
person-seq: seq(person)
person-seq <<< ('John', 'Smith') <<< ('Mary', 'Stuart')
person-seq: person[('John', 'Smith'), ('Mary', 'Stuart')]
last-name-seq: person-seq[name = 'John'] -> last-name

##############################
seq_element: any
seq_compare: (seq_element, seq_element) -> int

seq(element: seq_element, compare: seq_compare):
    head: blob(element)
    prepend(e: element) -> seq(element, compare)
        blob.append(e, sizeof(e))

int_seq: seq(int)
int_seq.prepend(5)

my-home: home + (street: 'Southdene')

find(name: unicode, element_seq: seq(element), name_map: element -> unicode) -> int | exception
    -> element_seq.contain(name, name_map)

student:
    name: unicode

student_seq: seq(student)
findy: find(name: 'Kris',
    element_seq: student_seq,
    name_map: (s: student) -> s.name)
findy << find('Kris',
    student_seq,
    student -> student.name)
case findy: find('Kris',
                 student_seq,
                 student -> student.name)
    exception: sys.exit(0)

case findy: find()
catch findy: find()

find -> int
find: -> int
find1: -> find
find: float -> int
find: (f: float) -> int(f)
find(f: float) -> int(f)
    case(f)
        5.0: out.print('5.0'), -> 0;
        4.0:
            out.print('4.0')
            -> 0;
        any: -> exception('not specified 5.0');;

find -> int | exception

case findy: find(5.0)
    exception -> out.print('Nothing found')
###########################
hello:
    var count: 0
    change(i: 0) -> count + i

run(i: 0) -> nil
    delay(hello)
        log.debug << hello.change(i)

var count: 0
yield(hello)
    count << hello.change(i)
log.debug << count

count: yield(hello)
    -> hello.change(i)
log.debug << count

# client1$ test.run(1)
# client2$ test.run(2)
######################################

context: contract
    clone() -> any
        class.forbidden: true
    enter() -> any
    leave() -> nil

file-context(file-name: unicode): context
    var file: io.file(file-name)

    enter() -> io.file
        file.open()
        log.debug << 'File {file-name} has been opened!'
        -> file

    leave() -> nil
        file.close()
        log.debug << 'File {file-name} has been closed!'

test-file: file-context('/tmp/test.txt')
    log.debug << test-file.content()

# asynchronous
io:
    chain:
        ready: () -> nil
    file: .chain
        open(file-name: unicode)

io.file.open('/tmp/file.txt')
    ready: log.debug << file.content()
        ready: file.close()
